# Phases 3-6: Implementation Guide Summary

This document provides a consolidated overview of Phases 3-6. For detailed step-by-step instructions, refer to the individual guide files (11-30).

---

## Phase 3: Enhanced Security (Week 5-6)

### Guide 11: Add PKCE Support

**What**: Proof Key for Code Exchange - prevents authorization code interception attacks

**Key Concepts**:
- **Code Challenge**: SHA256 hash of code verifier, sent during authorization
- **Code Verifier**: Random string (43-128 chars), sent during token exchange
- **Why**: Cryptographically binds authorization request to token request

**Implementation Steps**:
1. Update `AuthorizationCode` entity to store `codeChallenge` and `codeChallengeMethod`
2. Modify authorization endpoint to accept and validate PKCE parameters
3. Update token endpoint to verify code_verifier matches code_challenge
4. Create `PKCEValidator` utility class for SHA256 hashing
5. Make PKCE required for public clients, optional for confidential

**Resources**: RFC 7636 - https://datatracker.ietf.org/doc/html/rfc7636

---

### Guide 12: Implement State Parameter Validation

**What**: CSRF protection for OAuth flows

**Key Concepts**:
- **State**: Random opaque value generated by client
- **Validation**: Client verifies returned state matches sent state
- **Why**: Prevents CSRF attacks where attacker tricks user into authorizing attacker's account

**Implementation Steps**:
1. Already accepted in authorization endpoint - ensure it's required
2. Preserve state through login/consent flow (session or hidden form fields)
3. Return state in authorization response
4. Document for client implementations
5. Add validation in error scenarios

**Resources**: RFC 6749 Section 10.12 - https://datatracker.ietf.org/doc/html/rfc6749#section-10.12

---

### Guide 13: Add Refresh Token Flow

**What**: Allow clients to obtain new access tokens without user interaction

**Key Concepts**:
- **Refresh Tokens**: Long-lived credentials to obtain new access tokens
- **Token Rotation**: Issuing new refresh token on each refresh (best practice)
- **Revocation**: Ability to invalidate refresh token family

**Implementation Steps**:
1. Already created `RefreshToken` entity and repository in previous guides
2. Update token endpoint to handle `grant_type=refresh_token`
3. Implement refresh token validation (exists, not expired, not revoked)
4. Generate new access token (and optionally new refresh token)
5. Implement token family tracking for security
6. Handle refresh token rotation

**Token Endpoint Addition**:
```
POST /oauth2/token
grant_type=refresh_token&
refresh_token=REFRESH_TOKEN&
client_id=demo-client&
client_secret=demo-secret
```

**Resources**: RFC 6749 Section 6 - https://datatracker.ietf.org/doc/html/rfc6749#section-6

---

### Guide 14: Token Revocation Endpoint

**What**: Endpoint for clients to revoke access and refresh tokens

**Key Concepts**:
- **Revocation**: Explicitly invalidating tokens before expiration
- **Why**: User logout, security events, client uninstallation
- **Token Hint**: Specifying whether revoking access_token or refresh_token

**Implementation Steps**:
1. Create POST `/oauth2/revoke` endpoint
2. Accept `token` and optional `token_type_hint` parameters
3. Authenticate client (same as token endpoint)
4. Mark refresh token as revoked in database
5. For access tokens (if stored), mark as invalid
6. Revoke entire token family if refresh token revoked
7. Return 200 OK regardless (per spec, don't reveal if token existed)

**Resources**: RFC 7009 - https://datatracker.ietf.org/doc/html/rfc7009

---

### Guide 15: Client Credentials Flow

**What**: Server-to-server authentication without user involvement

**Key Concepts**:
- **Machine-to-Machine**: Service accounts, background jobs
- **No User Context**: Token represents the client application itself
- **Scopes**: Limited to what client is authorized for

**Implementation Steps**:
1. Add `grant_type=client_credentials` handler in token endpoint
2. Authenticate client (client_id + client_secret)
3. Verify client is allowed this grant type
4. Generate access token with client's allowed scopes
5. No refresh token issued (client can always request new token)
6. Token subject (`sub`) is client_id, not user_id

**Token Endpoint Addition**:
```
POST /oauth2/token
grant_type=client_credentials&
client_id=service-app&
client_secret=service-secret&
scope=api.read
```

**Resources**: RFC 6749 Section 4.4 - https://datatracker.ietf.org/doc/html/rfc6749#section-4.4

---

## Phase 4: User Experience (Week 7-8)

### Guide 16: Build Consent Screen

**What**: User-friendly UI for authorization consent

**Key Concepts**:
- **Scope Descriptions**: Human-readable explanations of permissions
- **Remember Consent**: Skip consent for previously approved scopes
- **Granular Control**: Allow users to approve/deny individual scopes

**Implementation Steps**:
1. Create enhanced consent.html template with better UX
2. Map technical scopes to user-friendly descriptions
3. Show app logo/name from client metadata
4. Implement consent storage in `user_consents` table
5. Check previous consents before showing screen
6. Allow users to modify granted scopes
7. Add "Always allow" checkbox option

---

### Guide 17: Scope Management

**What**: Define, register, and manage OAuth scopes

**Key Concepts**:
- **Standard Scopes**: openid, profile, email (OpenID Connect)
- **Custom Scopes**: Application-specific permissions
- **Scope Registry**: Database table defining available scopes

**Implementation Steps**:
1. Create `scopes` table with name, description, category
2. Seed standard OIDC scopes (openid, profile, email, address, phone)
3. Create scope registration API for admins
4. Implement scope validation against registry
5. Map scopes to claims (email scope → email claim)
6. Document scope meanings for API consumers

---

### Guide 18: Session Management with Redis

**What**: Scalable session storage and Single Sign-On foundation

**Key Concepts**:
- **Spring Session**: Store HTTP sessions in Redis instead of memory
- **Session Timeout**: Configure appropriate timeouts
- **Remember Me**: Persistent login option

**Implementation Steps**:
1. Add Spring Session Redis dependency
2. Configure Spring Session in application.yml
3. Verify sessions stored in Redis (use redis-cli)
4. Implement remember-me authentication
5. Configure session timeout policies
6. Handle session fixation attacks
7. Test session persistence across server restarts

---

### Guide 19: Remember-Me Functionality

**What**: Allow users to stay logged in across browser sessions

**Key Concepts**:
- **Persistent Token**: Stored in database and browser cookie
- **Security**: Token rotation on each use
- **Expiration**: Longer timeout than regular sessions (e.g., 30 days)

**Implementation Steps**:
1. Enable Spring Security's remember-me feature
2. Configure persistent token repository (database)
3. Create `persistent_logins` table
4. Add remember-me checkbox to login form
5. Configure token validity period
6. Implement token rotation for security
7. Test logout clears remember-me cookie

---

### Guide 20: Error Handling and User Feedback

**What**: Professional error pages and OAuth error handling

**Key Concepts**:
- **User-Friendly Messages**: Don't expose technical details
- **OAuth Error Standards**: Proper error codes and descriptions
- **Logging**: Detailed logging for debugging without exposing to users

**Implementation Steps**:
1. Create custom error pages (401, 403, 404, 500)
2. Implement @RestControllerAdvice for API error handling
3. Create Thymeleaf error templates
4. Log errors with context (user, client, flow step)
5. Implement graceful degradation
6. Add error tracking (could integrate Sentry/Rollbar later)
7. Test error scenarios systematically

---

## Phase 5: OpenID Connect (Week 9-10)

### Guide 21: Add ID Token Support

**What**: Issue ID tokens containing authentication information

**Key Concepts**:
- **ID Token**: JWT containing claims about authentication event
- **Standard Claims**: sub, iss, aud, exp, iat, auth_time, nonce
- **vs Access Token**: ID token is about user identity, access token is for authorization

**Implementation Steps**:
1. Create ID token generation method in JwtTokenProvider
2. Include standard OIDC claims (sub, iss, aud, exp, iat)
3. Add auth_time claim (when user authenticated)
4. Support nonce parameter (replay protection)
5. Include ID token in token response when scope includes "openid"
6. Sign ID token with same key as access tokens
7. Test ID token structure and claims

**Resources**: OpenID Connect Core - https://openid.net/specs/openid-connect-core-1_0.html

---

### Guide 22: UserInfo Endpoint

**What**: Endpoint for clients to retrieve user profile information

**Key Concepts**:
- **Standard Endpoint**: `/oauth2/userinfo`
- **Bearer Token**: Requires valid access token
- **Scope-Based Claims**: Return claims based on granted scopes

**Implementation Steps**:
1. Create GET/POST `/oauth2/userinfo` endpoint
2. Validate Bearer token from Authorization header
3. Extract user_id from token claims
4. Load user from database
5. Filter claims based on token scopes (profile → name, email → email)
6. Return JSON with user claims
7. Handle errors (invalid token, insufficient scopes)

**Claim Mapping**:
- `openid`: sub (user ID)
- `profile`: name, family_name, given_name, picture, etc.
- `email`: email, email_verified
- `address`: formatted address
- `phone`: phone_number, phone_number_verified

---

### Guide 23: Discovery Endpoint (.well-known)

**What**: Publish IdP metadata for client auto-configuration

**Key Concepts**:
- **OIDC Discovery**: Standard endpoint at `/.well-known/openid-configuration`
- **Metadata**: Lists all endpoints, supported features, algorithms
- **Auto-Configuration**: Clients can discover IdP capabilities automatically

**Implementation Steps**:
1. Create GET `/.well-known/openid-configuration` endpoint
2. Return JSON with metadata:
   - issuer (your IdP URL)
   - authorization_endpoint, token_endpoint, userinfo_endpoint
   - jwks_uri, revocation_endpoint
   - scopes_supported, response_types_supported
   - grant_types_supported, token_endpoint_auth_methods_supported
   - claims_supported
3. Make endpoint publicly accessible (no auth)
4. Test with OIDC libraries (should auto-configure)

**Resources**: OIDC Discovery - https://openid.net/specs/openid-connect-discovery-1_0.html

---

### Guide 24: JWKS Endpoint

**What**: Publish public keys for JWT signature verification

**Key Concepts**:
- **JWKS**: JSON Web Key Set - collection of cryptographic keys
- **Public Key Distribution**: Resource servers use this to verify JWTs
- **Key Rotation**: Support multiple keys for seamless rotation

**Implementation Steps**:
1. Create GET `/oauth2/jwks` endpoint
2. For HMAC (HS256): Don't expose secret (symmetric key)
3. Migrate to RSA (RS256) for production:
   - Generate RSA key pair
   - Sign tokens with private key
   - Expose public key in JWKS endpoint
4. Return JWK JSON format
5. Include kid (key ID) in JWT header
6. Support multiple keys (active + rotating)

**Note**: For learning, you can keep HS256. For production, use RS256 with JWKS.

---

### Guide 25: Claims Mapping

**What**: Map user attributes to standardized OIDC claims

**Key Concepts**:
- **Standard Claims**: Defined by OIDC spec (name, email, phone, etc.)
- **Custom Claims**: Application-specific user attributes
- **Scope-to-Claim Mapping**: Which scopes grant which claims

**Implementation Steps**:
1. Add additional user profile fields (given_name, family_name, picture, etc.)
2. Create database migration for new columns
3. Create ClaimsMapper service
4. Implement scope-based filtering
5. Support custom claims for application needs
6. Document claim meanings
7. Test UserInfo endpoint returns correct claims per scope

---

## Phase 6: Resource Server (Week 11-12)

### Guide 26: Build Protected API Endpoints

**What**: Create resource server with protected endpoints

**Key Concepts**:
- **Resource Server**: API that accepts OAuth access tokens
- **Protected Resources**: Endpoints requiring valid tokens
- **Separation**: Resource server is separate from authorization server

**Implementation Steps**:
1. Create new Spring Boot project `resource-server`
2. Add Spring Security OAuth2 Resource Server dependency
3. Create sample API endpoints (e.g., /api/profile, /api/data)
4. Configure JWT validation (using IdP's JWKS or shared secret)
5. Test with access tokens from client app
6. Return appropriate errors for invalid/missing tokens

---

### Guide 27: Implement Token Validation

**What**: Validate JWT access tokens in resource server

**Key Concepts**:
- **Signature Validation**: Verify token wasn't tampered with
- **Expiration Check**: Reject expired tokens
- **Issuer Validation**: Ensure token from trusted IdP
- **Audience Validation**: Token intended for this resource server

**Implementation Steps**:
1. Configure resource server with IdP's JWKS URI or shared secret
2. Spring Security automatically validates signature and expiration
3. Add custom validation for audience (aud claim)
4. Extract user information from token claims
5. Create @AuthenticationPrincipal for easy access to claims
6. Handle validation errors (401 Unauthorized)

**Configuration**:
```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8080
          jwk-set-uri: http://localhost:8080/oauth2/jwks
```

---

### Guide 28: Scope-Based Authorization

**What**: Enforce permissions based on token scopes

**Key Concepts**:
- **Scope Enforcement**: Check if token has required scope
- **Method Security**: Annotations like @PreAuthorize
- **Fine-Grained Access**: Different endpoints require different scopes

**Implementation Steps**:
1. Enable method security with @EnableMethodSecurity
2. Use @PreAuthorize("hasAuthority('SCOPE_read')") on endpoints
3. Extract scopes from JWT claims
4. Create custom authorization logic if needed
5. Return 403 Forbidden for insufficient scopes
6. Document required scopes for each endpoint

**Example**:
```java
@GetMapping("/api/profile")
@PreAuthorize("hasAuthority('SCOPE_profile')")
public UserProfile getProfile() {
    // Only accessible with 'profile' scope
}
```

---

### Guide 29: API Rate Limiting

**What**: Protect APIs from abuse with rate limiting

**Key Concepts**:
- **Rate Limiting**: Restrict requests per time window
- **Per-Client**: Different limits for different clients
- **Headers**: Return rate limit info in response headers

**Implementation Steps**:
1. Add Bucket4j or Resilience4j dependency for rate limiting
2. Create rate limiting interceptor
3. Store rate limit state in Redis (distributed rate limiting)
4. Configure limits per client or per user
5. Return 429 Too Many Requests when exceeded
6. Add X-RateLimit headers (X-RateLimit-Limit, X-RateLimit-Remaining)
7. Implement different tiers (free, premium)

---

### Guide 30: Introspection Endpoint

**What**: Endpoint for resource servers to validate opaque tokens

**Key Concepts**:
- **Token Introspection**: Ask authorization server if token is valid
- **Opaque Tokens**: Alternative to JWTs (random strings)
- **Metadata**: Return token's active status, scopes, user info

**Implementation Steps**:
1. Create POST `/oauth2/introspect` endpoint
2. Require client authentication
3. Accept token parameter
4. Lookup token in database (if using opaque tokens)
5. Return active status, scopes, expiration, user info
6. For JWTs: Validate and return claims
7. Resource servers can use this if not validating JWTs locally

**Response**:
```json
{
  "active": true,
  "scope": "openid profile email",
  "client_id": "demo-client",
  "username": "john.doe",
  "exp": 1700000000
}
```

**Resources**: RFC 7662 - https://datatracker.ietf.org/doc/html/rfc7662

---

## Testing Strategy

### Integration Testing
- Test complete flows end-to-end
- Use Spring MockMvc for controller tests
- Use @SpringBootTest for integration tests
- Test security configurations

### Security Testing
- Test authorization bypass attempts
- Test token manipulation
- Test expired/invalid tokens
- Test CSRF protection
- Test scope enforcement

### Performance Testing
- Load test token endpoint
- Measure JWT generation/validation time
- Test Redis session performance
- Monitor database query performance

---

## Deployment Considerations

### Security Hardening
- Use HTTPS in production (mkcert for local testing)
- Rotate secrets regularly
- Use environment variables for secrets
- Enable security headers (HSTS, CSP, etc.)
- Implement audit logging

### Monitoring
- Log authentication events
- Track token issuance
- Monitor failed login attempts
- Alert on suspicious patterns

### Scalability
- Use Redis for sessions (horizontal scaling)
- Consider JWT for stateless access tokens
- Database connection pooling
- Caching frequent queries

---

## Congratulations!

Upon completing all 30 guides, you will have built a production-quality OAuth 2.0/OpenID Connect Identity Provider with:

✅ Complete OAuth 2.0 flows (authorization code, refresh token, client credentials)
✅ Security features (PKCE, state, token rotation, revocation)
✅ OpenID Connect support (ID tokens, UserInfo, Discovery)
✅ Professional UX (consent screens, error handling, session management)
✅ Scalable architecture (Redis sessions, JWT tokens)
✅ Protected resource server with scope-based authorization
✅ Industry best practices and security standards

You now understand modern authentication and authorization at a deep level and can work confidently with production identity systems!

---

## Further Learning

Proceed to `next-steps.md` for advanced topics and real-world enhancements.
